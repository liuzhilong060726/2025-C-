#define _CRT_SECURE_NO_WARNINGS

/* 刘志龙 */
/* 2025/5/17 */

/* C语言进阶 */
#include <stdio.h>

/* 指针进阶练习 */
//int main() {
//	int a[3][4] = { 0 };
//	printf("%d\n", sizeof(a));// 48 - a表示整个数组，计算的是整个数组大小
//	printf("%d\n", sizeof(a[0][0]));// 4 - 数组第一行第一列元素大小
//	printf("%d\n", sizeof(a[0]));// 16 - a[0]表示整个数组第一行，计算的是数组第一行的大小
//	printf("%d\n", sizeof(a[0] + 1));// 4/8 - a[0]表示数组第一行首元素地址，a[0]+1 表示数组第一行第二个元素地址
//	printf("%d\n", sizeof(*(a[0] + 1)));// 4 - a[0]+1 表示数组第一行第二个元素地址，进引用后计算的是数组第一行第二个元素的大小
//	printf("%d\n", sizeof(a + 1));// 4/8 - a表示数组第一行地址，a+1 表示数组第二行地址
//	printf("%d\n", sizeof(*(a + 1)));// 16 - a+1 表示数组第二行地址，解引用后计算的是数组第二行大小
//	printf("%d\n", sizeof(&a[0] + 1));// 4/8 - a[0]表示数组第一行，&a[0]+1 表示数组第二行地址
//	printf("%d\n", sizeof(*(&a[0] + 1)));// 16 - &a[0]+1 表示数组第二行地址，解引用后计算的是数组第二行大小
//	printf("%d\n", sizeof(*a));// 16 - *a即a[0]表示数组第一行，计算的是数组第一行大小
//	printf("%d\n", sizeof(a[3]));// 16 - 由于sizeof内表达式不实际计算，但是会模拟一个数组，计算的是数组第四行大小
//	return 0;
//}

/* 练习 */
// // 1.
//int main() {
//	int a[5] = { 1,2,3,4,5 };
//	int* ptr = (int*)(&a + 1);// &a白哦时取出整个数组的地址，&a+1表示跳过整个数组，最后强制类型转换
//	printf("%d,%d", *(a + 1), *(ptr - 1));// 2,5
//	// *(a+1)表示数组第二个元素，*(ptr-1)表示减去int*各单位地址即数组最后一个元素
//	return 0;
//}

//// 2.
////由于还没学习结构体，这里告知结构体的大小是20个字节
//struct Test {
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
////假设p的值为0x100000。如下表表达式的值分别为多少 ?
////已知，结构体Test类型的变量大小是20个字节
//int main() {
//	// 特别注意的是这里的地址十六进制展现的
//	printf("%p\n", p + 0x1);// 0x100014
//	// 这里p指的就是结构体指针，加1表示加一个结构体数组大小的地址
//
//	printf("%p\n", (unsigned long)p + 0x1);// 0x100001
//	// 先将p强制类型转换成无符号长整型，在加1就只是将地址转化长对应十进制之后再加1
//
//	printf("%p\n", (unsigned int*)p + 0x1);// 0x100004
//	// 将p强制类型转换成整形指针，由于整形指针大小是4个字节，所以给p加1就是给地址加4个字节
//	return 0;
//}

//// 3.
//int main() {
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);// &a去取出的是整个数组的地址，加1表示跳过整个数组，强制类型转换后表示数组后的一个整形的地址
//	int* ptr2 = (int*)((int)a + 1);// a单独表示数组书元素的地址，转换成整形后加1，对应地址只加了一个字节
//	// 01000000 02000000 03000000 04000000 - 数组a在内存中的存储（小端字节序）
//	// 01 00000002 00000003 00000004 000000
//	// 02000000 - ptr2真实存储的值
//	printf("%x,%x", ptr1[-1], *ptr2);// 4，200000
//	// 给ptr1取第一个元素前的地址，表示a数组的最后一个元素
//	return 0;
//}

//// 4.
//int main() {
//	int a[3][2] = { (0,1),(2,3),(4,5) };// 这里要注意，(,)这是一个逗号表达式，数组中仅存出了三个值
//	// 1 2 3 0 0 0
//	int* p;
//	p = a[0];// a[0]数组表示第一行的地址
//	printf("%d", p[0]);// p[0]表示数组第一行第一个元素
//	return 0;
//}

//// 5.
//int main() {
//	int a[5][5];
//	// 00000 00000 00000 00000 000a00
//	// 0000 0000 0000 0000 000p0 0000
//	int(*p)[4];
//	p = a;// a表示第一行的地址，这里是将第一行的地址放在一个数组指针里，但由于第一行，但由于类型不匹配，访问时可能会出现变化
//	printf("%p %d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);// [4][2]表示第五行第三个元素，两个指针的差值表示两个指针之间的元素个数
//	// 由于是低地址减高地址，所以计算结果是-4，转换成二进制后
//	// 10000000000000000000000000000100
//	// 11111111111111111111111111111011
//	// 11111111111111111111111111111100
//	// 1111 1111 1111 1111 1111 1111 1111 1111 1100
//	// FFFFFFFC
//	return 0;
//}

//// 6.
//int main() {
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* ptr1 = (int*)(&aa + 1);// &aa表示取出整个二维数组的地址，加1表示跳过整个数组，强制类型转换为int*类型
//	int* ptr2 = (int*)(*(aa + 1));// aa表示数组第一行地址，加1表示是数组第二行地址，解引用表示第二行数组名，即aa[1]，它还可以表示第二行首元素的地址
//	printf("%d,%d", * (ptr1 - 1), * (ptr2 - 1));// 10，5
//	// ptr1-1表示数组最后一行个元素地址，ptr2-1表示数组第一行最后一个元素地址
//	return 0;
//}

//// 7.
//int main() {
//	char* a[] = { "work","at","alibaba" };
//	char** pa = a;
//	pa++;
//	printf("%s\n", *pa);// at
//	return 0;
//}

// 8.
int main() {
	char* c[] = { "ENETER","NEW","POINT","FIRST" };
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	printf("%s\n", **++cpp);// POINT
	printf("%s\n", *-- * ++cpp + 3);// ER
	printf("%s\n", *cpp[-2] + 3);// ST
	printf("%s\n", cpp[-1][-1] + 1);// EW

	return 0;
}